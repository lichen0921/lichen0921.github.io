
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>模仿AsyncTask实现串行执行的队列 | Launchercher</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="wIsper">
    
    <meta name="description" content="参考AsyncTask源码，依葫芦画瓢的实现一个串行执行的队列">
    
    
    
    
    
    <link rel="icon" href="/img/share.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.png">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.png">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/cloud.png" alt="Launchercher" title="Launchercher"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Launchercher">Launchercher</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">文章</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:launchercher.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/28/模仿AsyncTask实现串行执行的队列/" title="模仿AsyncTask实现串行执行的队列" itemprop="url">模仿AsyncTask实现串行执行的队列</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://launchercher.com" title="wIsper">wIsper</a>
    </p>
  <p class="article-time">
    <time datetime="2014-10-28T15:46:37.000Z" itemprop="datePublished">Oct 28 2014</time>
    Updated:<time datetime="2014-10-28T16:19:08.000Z" itemprop="dateModified">Oct 29 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
		</div>
		
		<p>参考<em>AsyncTask</em>源码，依葫芦画瓢的实现一个<strong>串行执行的队列</strong><br><a id="more"></a></p>
<blockquote>
<p>使用<code>AsyncTask</code>的规则</p>
<ul>
<li>AsyncTask的类必须在<code>UI线程</code>加载（从4.1开始系统会帮我们自动完成）</li>
<li>AsyncTask对象必须在<code>UI线程</code>创建</li>
<li>execute方法必须在<code>UI线程</code>调用</li>
<li>不要在你的程序中去<code>直接调用</code>onPreExecute(), onPostExecute, doInBackground, onProgressUpdate方法</li>
<li>一个AsyncTask对象只能执行<code>一次</code>，即只能调用一次execute方法，否则会报运行时异常</li>
<li>AsyncTask不是被设计为处理<code>耗时操作</code>的，耗时上限为几秒钟，如果要做长耗时操作，强烈建议你使用Executor，ThreadPoolExecutor以及FutureTask</li>
<li>在1.6之前，AsyncTask是串行执行任务的，1.6的时候AsyncTask开始采用线程池里处理并行任务，但是从3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来<code>串行</code>执行任务</li>
</ul>
</blockquote>
<p>当然我个人更建议使用<code>Handler</code>来实现异步。</p>
<blockquote>
<p>AsyncTask也经历过一段时期的折腾，现在稳定在串行执行。无论以后如何，串行思想还是值得学习的，应用的场合也是非常多。</p>
</blockquote>
<p>参考AsyncTask的源码，实现一个类似的<code>串行执行</code>的<code>队列</code>。</p>
<pre><code><span class="keyword">import</span> java.util.ArrayDeque;
<span class="keyword">import</span> java.util.concurrent.BlockingQueue;
<span class="keyword">import</span> java.util.concurrent.Executor;
<span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;
<span class="keyword">import</span> java.util.concurrent.ThreadFactory;
<span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;
<span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="javadoc">/**
 * Created by lichen
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticTask</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"StatisticTask"</span>;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">128</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() {
        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);

        <span class="keyword">public</span> Thread <span class="title">newThread</span>(Runnable r) {
            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"StatisticTask #"</span> + mCount.getAndIncrement());
        }
    };

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =
            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>);

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR
            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
            TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;

    <span class="keyword">private</span> WriteStatisticsAble mWriteStaticticsAble;
    <span class="keyword">private</span> BaseStatistics mBaseStatistics;
    <span class="keyword">private</span> StatisticType mStatisticType;

    <span class="keyword">private</span> <span class="keyword">static</span> StatisticTask sStatisticTask;

    <span class="keyword">public</span> <span class="keyword">static</span> StatisticTask <span class="title">getSyncInstance</span>(WriteStatisticsAble writeStaticticsAble) {
        getInstance();
        sStatisticTask.mWriteStaticticsAble = writeStaticticsAble;
        sStatisticTask.mStatisticType = StatisticType.SYNCHRONIZED;
        <span class="keyword">return</span> sStatisticTask;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> StatisticTask <span class="title">getProcessInstance</span>(BaseStatistics baseStatistics) {
        getInstance();
        sStatisticTask.mBaseStatistics = baseStatistics;
        sStatisticTask.mStatisticType = StatisticType.PROCESS;
        <span class="keyword">return</span> sStatisticTask;
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (sStatisticTask == <span class="keyword">null</span>) {
            <span class="keyword">synchronized</span> (StatisticTask.class) {
                <span class="keyword">if</span> (sStatisticTask == <span class="keyword">null</span>) {
                    sStatisticTask = <span class="keyword">new</span> StatisticTask();
                }
            }
        }
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>{
        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();
        Runnable mActive;

        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="keyword">final</span> Runnable r) {
            mTasks.offer(<span class="keyword">new</span> Runnable() {
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                    <span class="keyword">try</span> {
                        r.run();
                    } <span class="keyword">finally</span> {
                        scheduleNext();
                    }
                }
            });
            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) {
                scheduleNext();
            }
        }

        <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span>() {
            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) {
                THREAD_POOL_EXECUTOR.execute(mActive);
            }
        }
    }

    <span class="annotation">@Deprecated</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(Runnable runnable) {
        sDefaultExecutor.execute(runnable);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statistic</span>(RequestParams param, String action) {
        sDefaultExecutor.execute(<span class="keyword">new</span> StatisticRunnale(param, action));
    }

    <span class="keyword">private</span> <span class="keyword">enum</span> StatisticType {
        PROCESS, SYNCHRONIZED
    }

    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticRunnale</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

        <span class="keyword">private</span> RequestParams mParam;
        <span class="keyword">private</span> String mAction;

        <span class="keyword">private</span> <span class="title">StatisticRunnale</span>(RequestParams param, String action) {
            mParam = param;
            mAction = action;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            <span class="keyword">switch</span> (mStatisticType) {
                <span class="keyword">case</span> SYNCHRONIZED:
                    String data = SynchroStatistics.makeStatisticsData(mParam, mAction);
                    mWriteStaticticsAble.addStringStatistics(data);
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> PROCESS:
                    mBaseStatistics.addProcessStatistics(mParam, mAction);
                    <span class="keyword">break</span>;
            }
        }
    }
}
</code></pre><p>下面是源码的详细注释，来自于<a href="http://blog.csdn.net/singwhatiwanna/article/details/17596225" title="http://blog.csdn.net/singwhatiwanna/article/details/17596225" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/17596225</a></p>
<pre><code><span class="comment">/* 
 * Copyright (C) 2008 The Android Open Source Project 
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */</span>  

<span class="keyword">package</span> android.os;  

<span class="keyword">import</span> java.util.ArrayDeque;  
<span class="keyword">import</span> java.util.concurrent.BlockingQueue;  
<span class="keyword">import</span> java.util.concurrent.Callable;  
<span class="keyword">import</span> java.util.concurrent.CancellationException;  
<span class="keyword">import</span> java.util.concurrent.Executor;  
<span class="keyword">import</span> java.util.concurrent.ExecutionException;  
<span class="keyword">import</span> java.util.concurrent.FutureTask;  
<span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;  
<span class="keyword">import</span> java.util.concurrent.ThreadFactory;  
<span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;  
<span class="keyword">import</span> java.util.concurrent.TimeUnit;  
<span class="keyword">import</span> java.util.concurrent.TimeoutException;  
<span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;  
<span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;  

<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>{  
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG_TAG = <span class="string">"AsyncTask"</span>;  

    <span class="comment">//获取当前的cpu核心数  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();  
    <span class="comment">//线程池核心容量  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;  
    <span class="comment">//线程池最大容量  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;  
    <span class="comment">//过剩的空闲线程的存活时间  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;  
    <span class="comment">//ThreadFactory 线程工厂，通过工厂方法newThread来获取新线程  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() {  
        <span class="comment">//原子整数，可以在超高并发下正常工作  </span>
        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);  

        <span class="keyword">public</span> Thread <span class="title">newThread</span>(Runnable r) {  
            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());  
        }  
    };  
    <span class="comment">//静态阻塞式队列，用来存放待执行的任务，初始容量：128个  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =  
            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);  

    <span class="javadoc">/** 
     * 静态并发线程池，可以用来并行执行任务，尽管从3.0开始，AsyncTask默认是串行执行任务 
     * 但是我们仍然能构造出并行的AsyncTask 
     */</span>  
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR  
            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,  
                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);  

    <span class="javadoc">/** 
     * 静态串行任务执行器，其内部实现了串行控制， 
     * 循环的取出一个个任务交给上述的并发线程池去执行 
     */</span>  
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();  
    <span class="comment">//消息类型：发送结果  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_RESULT = <span class="number">0x1</span>;  
    <span class="comment">//消息类型：更新进度  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_PROGRESS = <span class="number">0x2</span>;  
    <span class="javadoc">/**静态Handler，用来发送上述两种通知，采用UI线程的Looper来处理消息 
     * 这就是为什么AsyncTask必须在UI线程调用，因为子线程 
     * 默认没有Looper无法创建下面的Handler，程序会直接Crash 
     */</span>  
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler();  
    <span class="comment">//默认任务执行器，被赋值为串行任务执行器，就是它，AsyncTask变成串行的了  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;  
    <span class="comment">//如下两个变量我们先不要深究，不影响我们对整体逻辑的理解  </span>
    <span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;  
    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;  
    <span class="comment">//任务的状态 默认为挂起，即等待执行，其类型标识为易变的（volatile）  </span>
    <span class="keyword">private</span> <span class="keyword">volatile</span> Status mStatus = Status.PENDING;  
    <span class="comment">//原子布尔型，支持高并发访问，标识任务是否被取消  </span>
    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mCancelled = <span class="keyword">new</span> AtomicBoolean();  
    <span class="comment">//原子布尔型，支持高并发访问，标识任务是否被执行过  </span>
    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mTaskInvoked = <span class="keyword">new</span> AtomicBoolean();  

    <span class="comment">/*串行执行器的实现，我们要好好看看，它是怎么把并行转为串行的 
     *目前我们需要知道，asyncTask.execute(Params ...)实际上会调用 
     *SerialExecutor的execute方法，这一点后面再说明。也就是说：当你的asyncTask执行的时候， 
     *首先你的task会被加入到任务队列，然后排队，一个个执行 
     */</span>  
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>{  
        <span class="comment">//线性双向队列，用来存储所有的AsyncTask任务  </span>
        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();  
        <span class="comment">//当前正在执行的AsyncTask任务  </span>
        Runnable mActive;  

        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="keyword">final</span> Runnable r) {  
            <span class="comment">//将新的AsyncTask任务加入到双向队列中  </span>
            mTasks.offer(<span class="keyword">new</span> Runnable() {  
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {  
                    <span class="keyword">try</span> {  
                        <span class="comment">//执行AsyncTask任务  </span>
                        r.run();  
                    } <span class="keyword">finally</span> {  
                        <span class="comment">//当前AsyncTask任务执行完毕后，进行下一轮执行，如果还有未执行任务的话  </span>
                        <span class="comment">//这一点很明显体现了AsyncTask是串行执行任务的，总是一个任务执行完毕才会执行下一个任务  </span>
                        scheduleNext();  
                    }  
                }  
            });  
            <span class="comment">//如果当前没有任务在执行，直接进入执行逻辑  </span>
            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) {  
                scheduleNext();  
            }  
        }  

        <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span>() {  
            <span class="comment">//从任务队列中取出队列头部的任务，如果有就交给并发线程池去执行  </span>
            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) {  
                THREAD_POOL_EXECUTOR.execute(mActive);  
            }  
        }  
    }  

    <span class="javadoc">/** 
     * 任务的三种状态 
     */</span>  
    <span class="keyword">public</span> <span class="keyword">enum</span> Status {  
        <span class="javadoc">/** 
         * 任务等待执行 
         */</span>  
        PENDING,  
        <span class="javadoc">/** 
         * 任务正在执行 
         */</span>  
        RUNNING,  
        <span class="javadoc">/** 
         * 任务已经执行结束 
         */</span>  
        FINISHED,  
    }  

    <span class="javadoc">/** 隐藏API：在UI线程中调用，用来初始化Handler */</span>  
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span>() {  
        sHandler.getLooper();  
    }  

    <span class="javadoc">/** 隐藏API：为AsyncTask设置默认执行器 */</span>  
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultExecutor</span>(Executor exec) {  
        sDefaultExecutor = exec;  
    }  

    <span class="javadoc">/** 
     * Creates a new asynchronous task. This constructor must be invoked on the UI thread. 
     */</span>  
    <span class="keyword">public</span> <span class="title">AsyncTask</span>() {  
        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() {  
            <span class="keyword">public</span> Result <span class="title">call</span>() <span class="keyword">throws</span> Exception {  
                mTaskInvoked.set(<span class="keyword">true</span>);  

                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  
                <span class="comment">//noinspection unchecked  </span>
                <span class="keyword">return</span> postResult(doInBackground(mParams));  
            }  
        };  

        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) {  
            <span class="annotation">@Override</span>  
            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span>() {  
                <span class="keyword">try</span> {  
                    postResultIfNotInvoked(get());  
                } <span class="keyword">catch</span> (InterruptedException e) {  
                    android.util.Log.w(LOG_TAG, e);  
                } <span class="keyword">catch</span> (ExecutionException e) {  
                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,  
                            e.getCause());  
                } <span class="keyword">catch</span> (CancellationException e) {  
                    postResultIfNotInvoked(<span class="keyword">null</span>);  
                }  
            }  
        };  
    }  

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span>(Result result) {  
        <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();  
        <span class="keyword">if</span> (!wasTaskInvoked) {  
            postResult(result);  
        }  
    }  
    <span class="comment">//doInBackground执行完毕，发送消息  </span>
    <span class="keyword">private</span> Result <span class="title">postResult</span>(Result result) {  
        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  
        Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,  
                <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));  
        message.sendToTarget();  
        <span class="keyword">return</span> result;  
    }  

    <span class="javadoc">/** 
     * 返回任务的状态 
     */</span>  
    <span class="keyword">public</span> <span class="keyword">final</span> Status <span class="title">getStatus</span>() {  
        <span class="keyword">return</span> mStatus;  
    }  

    <span class="javadoc">/** 
     * 这个方法是我们必须要重写的，用来做后台计算 
     * 所在线程：后台线程 
     */</span>  
    <span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInBackground</span>(Params... params);  

    <span class="javadoc">/** 
     * 在doInBackground之前调用，用来做初始化工作 
     * 所在线程：UI线程 
     */</span>  
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span>() {  
    }  

    <span class="javadoc">/** 
     * 在doInBackground之后调用，用来接受后台计算结果更新UI 
     * 所在线程：UI线程 
     */</span>  
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span>(Result result) {  
    }  

    <span class="javadoc">/** 
     * Runs on the UI thread after {@link #publishProgress} is invoked. 
     /** 
     * 在publishProgress之后调用，用来更新计算进度 
     * 所在线程：UI线程 
     */</span>  
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span>(Progress... values) {  
    }  

     <span class="javadoc">/** 
     * cancel被调用并且doInBackground执行结束，会调用onCancelled，表示任务被取消 
     * 这个时候onPostExecute不会再被调用，二者是互斥的，分别表示任务取消和任务执行完成 
     * 所在线程：UI线程 
     */</span>  
    <span class="annotation">@SuppressWarnings</span>({<span class="string">"UnusedParameters"</span>})  
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span>(Result result) {  
        onCancelled();  
    }      

    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span>() {  
    }  

    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span>() {  
        <span class="keyword">return</span> mCancelled.get();  
    }  

    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cancel</span>(<span class="keyword">boolean</span> mayInterruptIfRunning) {  
        mCancelled.set(<span class="keyword">true</span>);  
        <span class="keyword">return</span> mFuture.cancel(mayInterruptIfRunning);  
    }  

    <span class="keyword">public</span> <span class="keyword">final</span> Result <span class="title">get</span>() <span class="keyword">throws</span> InterruptedException, ExecutionException {  
        <span class="keyword">return</span> mFuture.get();  
    }  

    <span class="keyword">public</span> <span class="keyword">final</span> Result <span class="title">get</span>(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException,  
            ExecutionException, TimeoutException {  
        <span class="keyword">return</span> mFuture.get(timeout, unit);  
    }  

    <span class="javadoc">/** 
     * 这个方法如何执行和系统版本有关，在AsyncTask的使用规则里已经说明，如果你真的想使用并行AsyncTask， 
     * 也是可以的，只要稍作修改 
     * 必须在UI线程调用此方法 
     */</span>  
    <span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span>(Params... params) {  
        <span class="comment">//串行执行  </span>
        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);  
        <span class="comment">//如果我们想并行执行，这样改就行了，当然这个方法我们没法改  </span>
        <span class="comment">//return executeOnExecutor(THREAD_POOL_EXECUTOR, params);  </span>
    }  

    <span class="javadoc">/** 
     * 通过这个方法我们可以自定义AsyncTask的执行方式，串行or并行，甚至可以采用自己的Executor 
     * 为了实现并行，我们可以在外部这么用AsyncTask： 
     * asyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, Params... params); 
     * 必须在UI线程调用此方法 
     */</span>  
    <span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span>(Executor exec,  
            Params... params) {  
        <span class="keyword">if</span> (mStatus != Status.PENDING) {  
            <span class="keyword">switch</span> (mStatus) {  
                <span class="keyword">case</span> RUNNING:  
                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span>  
                            + <span class="string">" the task is already running."</span>);  
                <span class="keyword">case</span> FINISHED:  
                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span>  
                            + <span class="string">" the task has already been executed "</span>  
                            + <span class="string">"(a task can be executed only once)"</span>);  
            }  
        }  

        mStatus = Status.RUNNING;  
        <span class="comment">//这里#onPreExecute会最先执行  </span>
        onPreExecute();  

        mWorker.mParams = params;  
        <span class="comment">//然后后台计算#doInBackground才真正开始  </span>
        exec.execute(mFuture);  
        <span class="comment">//接着会有#onProgressUpdate被调用，最后是#onPostExecute  </span>

        <span class="keyword">return</span> <span class="keyword">this</span>;  
    }  

    <span class="javadoc">/** 
     * 这是AsyncTask提供的一个静态方法，方便我们直接执行一个runnable 
     */</span>  
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span>(Runnable runnable) {  
        sDefaultExecutor.execute(runnable);  
    }  

    <span class="javadoc">/** 
     * 打印后台计算进度，onProgressUpdate会被调用 
     */</span>  
    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span>(Progress... values) {  
        <span class="keyword">if</span> (!isCancelled()) {  
            sHandler.obtainMessage(MESSAGE_POST_PROGRESS,  
                    <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();  
        }  
    }  

    <span class="comment">//任务结束的时候会进行判断，如果任务没有被取消，则onPostExecute会被调用  </span>
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span>(Result result) {  
        <span class="keyword">if</span> (isCancelled()) {  
            onCancelled(result);  
        } <span class="keyword">else</span> {  
            onPostExecute(result);  
        }  
        mStatus = Status.FINISHED;  
    }  

    <span class="comment">//AsyncTask内部Handler，用来发送后台计算进度更新消息和计算完成消息  </span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{  
        <span class="annotation">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>})  
        <span class="annotation">@Override</span>  
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(Message msg) {  
            AsyncTaskResult result = (AsyncTaskResult) msg.obj;  
            <span class="keyword">switch</span> (msg.what) {  
                <span class="keyword">case</span> MESSAGE_POST_RESULT:  
                    <span class="comment">// There is only one result  </span>
                    result.mTask.finish(result.mData[<span class="number">0</span>]);  
                    <span class="keyword">break</span>;  
                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:  
                    result.mTask.onProgressUpdate(result.mData);  
                    <span class="keyword">break</span>;  
            }  
        }  
    }  

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>{  
        Params[] mParams;  
    }  

    <span class="annotation">@SuppressWarnings</span>({<span class="string">"RawUseOfParameterizedType"</span>})  
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>{  
        <span class="keyword">final</span> AsyncTask mTask;  
        <span class="keyword">final</span> Data[] mData;  

        AsyncTaskResult(AsyncTask task, Data... data) {  
            mTask = task;  
            mData = data;  
        }  
    }  
} 
</code></pre><p>两篇很有启发的博文</p>
<p><a href="http://blog.csdn.net/singwhatiwanna/article/details/17596225" title="http://blog.csdn.net/singwhatiwanna/article/details/17596225" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/17596225</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/11711405" title="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/11711405</a></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Android/">Android</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://launchercher.com/2014/10/28/模仿AsyncTask实现串行执行的队列/" data-title="模仿AsyncTask实现串行执行的队列 | Launchercher" data-tsina="606788262" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2014/10/08/Markdown语法/"  title="Markdown语法">
 <strong>NEXT:</strong><br/> 
 <span>Markdown语法
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Android/" title="Android">Android<sup>4</sup></a></li>
		
			<li><a href="/tags/Common/" title="Common">Common<sup>2</sup></a></li>
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m wIsper in Beijing who come from Tianjin. Engaged development of Android. Interested in Data Analysis. <br/>
			My parents build me good Foundation. My honey Michuann do solidly support me with deep Understanding. Love makes me step solid by step to make Technology to Art!</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/606788262" target="_blank" title="weibo"></a>
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://launchercher.com" target="_blank" title="wIsper">wIsper</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
